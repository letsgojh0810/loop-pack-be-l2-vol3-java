# 01. 요구사항 명세

## 1. 이 서비스가 풀려는 문제

감성 이커머스라는 컨셉 아래, 유저가 브랜드 상품을 탐색하고 좋아요를 누르고, 여러 상품을 한 번에 주문하는 흐름을 만든다.
회원 도메인은 1주차에 완성됐으므로 제외하고, 이번 설계 범위는 **브랜드, 상품, 좋아요, 주문**이다.

각 도메인이 풀려는 문제를 관점별로 정리하면:

**사용자 관점**
- 여러 브랜드의 상품을 한 곳에서 탐색하고, 마음에 드는 상품에 관심을 표시하고 싶다.
- 여러 상품을 한 번에 골라서 주문하고, 내 주문 이력을 언제든 확인하고 싶다.
- 과거 주문에서 "그때 얼마였지?"를 확인할 수 있어야 한다 → 주문 시점 가격이 보존되어야 하는 이유.

**비즈니스 관점**
- 어드민이 브랜드와 상품을 등록/관리할 수 있어야 한다.
- 좋아요 데이터는 단순 기능이 아니라, 향후 랭킹/추천의 기반 데이터가 된다.
- 상품 가격이 변경되더라도 이미 완료된 주문 금액에 영향이 가면 안 된다.

**시스템 관점**
- 주문 시 재고 차감이 정합성 있게 이루어져야 한다. 재고가 음수가 되거나, 동시 주문으로 초과 차감되면 안 된다.
- 브랜드 삭제 시 소속 상품이 고아 상태로 남으면 안 된다. 하지만 그 상품에 걸린 주문/좋아요 이력은 보존되어야 한다.
- 결제 시스템은 아직 없다. 선결 조건만 충족하면 주문은 즉시 완료된다. 하지만 나중에 결제/쿠폰이 추가될 수 있으므로, 확장 여지를 닫아버리면 안 된다.

### 액터

| 액터 | 설명 | 인증 방식 |
|------|------|-----------|
| 고객 (User) | 상품 탐색, 좋아요, 주문을 수행하는 일반 사용자 | `X-Loopers-LoginId` + `X-Loopers-LoginPw` |
| 어드민 (Admin) | 브랜드/상품/주문을 관리하는 사내 운영자 | `X-Loopers-Ldap: loopers.admin` |

### 핵심 도메인

| 도메인 | 핵심 책임 |
|--------|-----------|
| Brand | 상품을 묶는 브랜드 단위. 어드민이 관리한다. |
| Product | 가격, 재고를 가진 판매 단위. 브랜드에 종속된다. |
| ProductLike | 고객의 상품 관심 표시. 향후 랭킹/추천 데이터 기반이 된다. |
| Order / OrderItem | 고객의 구매 행위. 주문 시점의 상품 정보를 스냅샷으로 보존한다. |

---

## 2. 설계 판단

요구사항만으로는 결정할 수 없는 부분들이 많았다. 아래는 고민 과정과 결정 근거를 함께 정리한 것이다.

### 삭제 전략: Soft Delete

BaseEntity에 이미 `deletedAt`이 내장되어 있고, 주문 이력과 좋아요 데이터를 보존해야 하므로 soft delete를 사용한다.

다만 soft delete를 쓰면서 **브랜드 이름에 DB UNIQUE 제약을 거는 건 충돌이 생긴다.** "Nike"를 삭제(soft)한 뒤 새로운 "Nike"를 등록하면 UNIQUE 위반이 난다. 처음엔 `UNIQUE(name, deleted_at)` 복합 유니크를 고민했는데, MySQL에서 NULL이 포함된 유니크 인덱스 동작이 까다롭다. 결국 **DB UNIQUE 제약은 걸지 않고, Application 레벨에서 활성 브랜드(`deleted_at IS NULL`) 중 동일 이름을 검사**하는 방식으로 결정했다.

### 주문 완료 조건: 선결 조건 충족 = 즉시 완료

결제 시스템이 없으므로 주문 상태(CREATED, CONFIRMED, CANCELLED 같은) 관리가 불필요하다. 선결 조건(상품 존재, 재고 충분)만 통과하면 주문은 바로 완료다. 그래서 Order 엔티티에 `status` 필드를 넣지 않았다.

다만 나중에 결제가 추가되면 status 컬럼을 새로 넣어야 하는 마이그레이션이 발생한다. 이 부분은 인지하고 있지만, 지금 쓰지도 않을 필드를 미리 넣어두는 건 과설계라고 판단했다. 결제가 도입될 때 `ALTER TABLE ADD COLUMN`으로 충분히 대응 가능하다.

### 좋아요 멱등성: 에러 대신 무시

이미 좋아요한 상태에서 다시 POST가 오면 409를 줄지, 그냥 200으로 무시할지 고민했다. 실제 쇼핑몰 앱에서 유저가 좋아요 버튼을 연타하거나, 네트워크 재시도로 같은 요청이 두 번 오는 건 흔한 일이다. 그때마다 에러를 던지면 클라이언트 처리가 번거로워진다. **멱등하게 200 OK를 반환**하는 게 클라이언트 구현도 편하고 안전하다. 취소(DELETE)도 마찬가지 — 이미 취소된 상태에서 다시 요청이 와도 200 OK.

### 좋아요 목록 조회: 본인만

`/api/v1/users/{userId}/likes`에서 userId가 본인이 아닌 경우를 403으로 막는다. 현재 요구사항에 소셜 기능(다른 사람의 좋아요 목록 보기)이 없고, "내가 좋아요 한 상품 목록 조회"라고 명시되어 있다. 사실 URI를 `/api/v1/users/me/likes`로 바꾸는 게 더 자연스러운데, 원본 요구사항의 URI를 그대로 따랐다.

### 주문 스냅샷 범위

주문 시점에 OrderItem에 저장할 정보를 **상품명, 가격, 브랜드명**으로 결정했다. 이미지 URL까지 넣을지 고민했는데, 주문 이력 화면에서 가장 중요한 건 "무슨 상품을, 얼마에, 몇 개 샀는지"다. 이미지는 상품이 살아있으면 원본에서 가져올 수 있고, 삭제됐으면 기본 이미지를 보여주면 된다. 필요해지면 나중에 컬럼을 추가하면 되므로 최소한으로 가져간다.

### 주문 항목 중복 처리

같은 주문 요청에 동일 상품이 여러 번 들어오는 경우를 어떻게 처리할지 — 예를 들어 `[{productId:1, qty:2}, {productId:1, qty:3}]`. 합산해서 qty:5로 처리하는 방법도 있지만, 클라이언트가 보낸 데이터를 서버가 자의적으로 변형하는 건 오히려 혼란을 줄 수 있다. **400으로 거부하고 클라이언트가 정리해서 보내도록 강제**한다. 입력 정합성은 입구에서 막는 게 깔끔하다.

### 주문 수량 제한

한 상품에 수량 제한이 없으면 qty:999999 같은 요청이 들어올 수 있다. 일반적인 쇼핑몰에서 한 번에 99개 이상 주문하는 경우는 거의 없으므로, **단일 항목 최대 수량을 99개로 제한**한다. 이건 비즈니스 정책이므로 나중에 바뀔 수 있지만, 아무 제한이 없는 것보단 낫다.

### 재고 0 상품 노출

재고가 0인 상품을 목록에서 숨길지 말지 — **노출하되 주문만 불가**로 결정했다. 재고가 없다고 숨겨버리면 유저 입장에서 "어? 아까 본 상품이 사라졌네?" 하는 혼란이 생긴다. 품절 상태를 보여주는 게 더 자연스러운 UX다.

### 어드민 목록에서 삭제된 데이터

어드민은 운영자니까 삭제된 브랜드/상품도 확인할 수 있어야 한다. 어드민 목록 조회 API에 **`deleted` 파라미터를 추가**해서, `deleted=true`면 삭제된 것만, `deleted=false`(기본값)면 활성 데이터만 보여주는 방식으로 처리한다.

### 상품 조회 시 브랜드 정보 조회

상품 응답에 브랜드 정보(id, 이름)를 포함해야 하는데, Product 엔티티에는 brandId만 있다. JPA 연관관계를 안 쓰기로 했으므로 두 가지 방법이 있다:
- A) 쿼리 레벨에서 join → 성능은 좋지만 ID 참조 원칙과 다소 충돌
- B) 상품 조회 후 brandId 목록으로 Brand를 별도 조회 → N+1은 아니고 2번 쿼리

**목록 조회는 쿼리 join, 상세 조회는 별도 조회**로 갔다. 목록은 성능이 중요하고, 상세는 한 건이라 브랜드 한 건 더 조회해도 문제없다.

### 좋아요 수 집계

상품 목록에서 좋아요 수를 보여줘야 하고, `likes_desc` 정렬도 지원한다. Product에 `likeCount` 같은 비정규화 필드를 넣을지 고민했는데, 현재 트래픽 규모에서는 **COUNT 서브쿼리로 충분**하다. 비정규화는 카운트 정합성 관리(좋아요 등록/취소 시 동기화) 비용이 생기므로, 성능 문제가 실제로 발생할 때 도입하는 게 맞다.

---

## 3. 기능 요구사항

### 3.1 브랜드 (Brand)

#### 고객 API (`/api/v1`)

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 브랜드 조회 | GET | `/api/v1/brands/{brandId}` | X | 단일 브랜드 정보를 조회한다. 삭제된 브랜드는 404. |

**고객에게 제공하는 브랜드 정보:** id, 이름, 설명, 이미지 URL

#### 어드민 API (`/api-admin/v1`)

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 브랜드 목록 조회 | GET | `/api-admin/v1/brands?page=0&size=20&deleted=false` | LDAP | 등록된 브랜드 목록. `deleted=true`로 삭제된 브랜드도 조회 가능. |
| 브랜드 상세 조회 | GET | `/api-admin/v1/brands/{brandId}` | LDAP | 단일 브랜드 상세 정보 (삭제된 것도 조회 가능) |
| 브랜드 등록 | POST | `/api-admin/v1/brands` | LDAP | 새 브랜드 등록 |
| 브랜드 수정 | PUT | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 정보 수정 |
| 브랜드 삭제 | DELETE | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 soft delete + 해당 상품 일괄 soft delete |

**어드민에게 추가 제공하는 정보:** createdAt, updatedAt, deletedAt, 소속 상품 수

**브랜드 등록/수정 시 검증:**
- 이름: 필수, 빈 값 불가
- 이름 중복: 활성 브랜드(`deleted_at IS NULL`) 중 동일 이름 등록 불가 (CONFLICT)

---

### 3.2 상품 (Product)

#### 고객 API (`/api/v1`)

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 상품 목록 조회 | GET | `/api/v1/products` | X | 상품 목록 (필터 + 정렬 + 페이지네이션). 삭제된 상품 제외, 재고 0 포함. |
| 상품 상세 조회 | GET | `/api/v1/products/{productId}` | X | 단일 상품 정보. 삭제된 상품은 404. |

**상품 목록 쿼리 파라미터:**

| 파라미터 | 타입 | 기본값 | 설명 |
|----------|------|--------|------|
| `brandId` | Long | - | 특정 브랜드 필터링 (선택) |
| `sort` | String | `latest` | 정렬 기준: `latest`, `price_asc`, `likes_desc` |
| `page` | int | 0 | 페이지 번호 |
| `size` | int | 20 | 페이지당 상품 수 |

**고객에게 제공하는 상품 정보:** id, 상품명, 설명, 가격, 재고, 이미지 URL, 브랜드 정보(id, 이름), 좋아요 수

> 좋아요 수는 `product_likes` 테이블의 COUNT 서브쿼리로 집계한다.
> 목록 조회 시 브랜드 정보는 쿼리 레벨 join으로 가져온다.

#### 어드민 API (`/api-admin/v1`)

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 상품 목록 조회 | GET | `/api-admin/v1/products?page=0&size=20&brandId={brandId}&deleted=false` | LDAP | 등록된 상품 목록. `deleted=true`로 삭제된 상품도 조회 가능. |
| 상품 상세 조회 | GET | `/api-admin/v1/products/{productId}` | LDAP | 상품 상세 정보 (삭제된 것도 조회 가능) |
| 상품 등록 | POST | `/api-admin/v1/products` | LDAP | 새 상품 등록 |
| 상품 수정 | PUT | `/api-admin/v1/products/{productId}` | LDAP | 상품 정보 수정 |
| 상품 삭제 | DELETE | `/api-admin/v1/products/{productId}` | LDAP | 상품 soft delete |

**상품 등록 시 제약:**
- 브랜드: 반드시 이미 등록된(삭제되지 않은) 브랜드여야 함
- 상품명: 필수
- 가격: 0 이상
- 재고: 0 이상

**상품 수정 시 제약:**
- 브랜드는 변경 불가
- 나머지 필드만 수정 가능

---

### 3.3 좋아요 (ProductLike)

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 좋아요 등록 | POST | `/api/v1/products/{productId}/likes` | O | 상품에 좋아요. 멱등 처리 (이미 있으면 무시). |
| 좋아요 취소 | DELETE | `/api/v1/products/{productId}/likes` | O | 좋아요 해제. 멱등 처리 (없으면 무시). |
| 내 좋아요 목록 | GET | `/api/v1/users/{userId}/likes` | O | 본인이 좋아요한 상품 목록. userId ≠ 본인이면 403. |

**좋아요 등록 제약:**
- 삭제된 상품에는 좋아요 불가 (404)
- 이미 좋아요한 상태에서 재요청 시 200 OK (멱등)

**좋아요 취소:**
- 삭제된 상품이라도 기존 좋아요는 취소 가능 (상품 검증 생략)
- 이미 취소된 상태에서 재요청 시 200 OK (멱등)

**좋아요 목록 응답:**
- 좋아요한 상품 정보 (id, 상품명, 가격, 브랜드명, 이미지 URL)
- 삭제된 상품은 DB 쿼리 레벨에서 `products.deleted_at IS NULL` join으로 제외

---

### 3.4 주문 (Order)

#### 고객 API (`/api/v1`)

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 주문 생성 | POST | `/api/v1/orders` | O | 다건 상품 주문. 재고 확인 및 차감. 스냅샷 저장. |
| 주문 목록 조회 | GET | `/api/v1/orders?startAt=..&endAt=..&page=0&size=20` | O | 기간별 주문 목록 (페이지네이션) |
| 주문 상세 조회 | GET | `/api/v1/orders/{orderId}` | O | 단일 주문 상세 (주문 항목 포함) |

**주문 생성 요청:**
```json
{
  "items": [
    { "productId": 1, "quantity": 2 },
    { "productId": 3, "quantity": 1 }
  ]
}
```

**주문 생성 시 처리 흐름:**
1. 주문 항목이 비어있지 않은지 확인
2. 동일 상품 중복 여부 확인 (같은 productId가 두 번 오면 400 거부)
3. 각 항목의 수량이 1~99 범위인지 확인
4. 요청된 상품들이 모두 존재하고 삭제되지 않았는지 확인
5. 각 상품의 재고가 요청 수량 이상인지 확인
6. 재고 차감
7. 주문 시점의 상품 정보를 OrderItem에 스냅샷으로 저장 (상품명, 가격, 브랜드명)
8. 총 주문 금액 계산 (각 항목의 가격 x 수량의 합)
9. Order 생성 (선결 조건 통과 = 주문 완료)

**주문 생성 실패 조건:**
- 주문 항목이 비어있음 → 400
- 동일 상품이 중복으로 포함됨 → 400
- 수량이 1~99 범위 밖 → 400
- 상품이 존재하지 않거나 삭제됨 → 404
- 재고 부족 → 400 (어떤 상품이 부족한지 메시지에 포함)

**주문 상세 조회:**
- 본인의 주문만 조회 가능 (타인 주문 접근 시 403)
- 주문 정보: id, 총 금액, 주문 일시
- 주문 항목: 상품 스냅샷(상품명, 가격, 브랜드명), 수량, 소계

#### 어드민 API (`/api-admin/v1`)

| 기능 | METHOD | URI | 인증 | 설명 |
|------|--------|-----|------|------|
| 주문 목록 조회 | GET | `/api-admin/v1/orders?page=0&size=20` | LDAP | 전체 주문 목록 (페이지네이션) |
| 주문 상세 조회 | GET | `/api-admin/v1/orders/{orderId}` | LDAP | 단일 주문 상세 (주문자 정보 포함) |

---

## 4. 향후 확장 시 영향 범위

지금은 스코프 밖이지만, 나중에 추가될 때 현재 설계에 미치는 영향을 미리 정리해둔다.

| 기능 | 현재 | 추가 시 영향 |
|------|------|-------------|
| 결제 | 없음. 주문 = 완료. | Order에 `status` 컬럼 추가 (`ALTER TABLE`). 주문 생성 시퀀스에서 재고 차감 후 결제 단계 삽입. 실패 시 재고 복원(보상 트랜잭션) 필요. |
| 주문 취소 | 없음 | 취소 API + 재고 복원 로직. status 필드 필요. |
| 쿠폰 | 없음 | 주문 생성 흐름에서 재고 확인과 주문 생성 사이에 쿠폰 검증/적용 단계 삽입. Order에 할인 금액 필드 추가. |
| 동시성 제어 | 기본 구현 (Application 레벨 검증) | 비관적 락(`SELECT FOR UPDATE`) 또는 낙관적 락(`@Version`), DB `CHECK (stock >= 0)` |
| 좋아요 수 비정규화 | COUNT 쿼리 | Product에 `like_count` 컬럼 추가. 좋아요 등록/취소 시 동기화 필요. 정합성 관리 비용 발생. |
